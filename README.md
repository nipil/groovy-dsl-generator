# groovy-dsl-generator

a bison/flex tool to generate classes from a sample dsl

# requirements

    sudo apt-get install make build-essential bison flex groovy

# build

    cd src && make

# use

Edit a definition file, or use one in `samples-working`

Generate groovy classes and test dsl file :

    src/gdg path/to/definition/file

Then use the test command provided at the end of generation to run the DSL classes against the DSL test file

# example

Groovy source generation :

    $ src/gdg samples-working/0003.def Target package : org.example.dsl.bank

    Parsed 3 closure declaration: person statistics transaction
    Parsed 2 top-level DSL keywords: account(txt,statistics) manager(person)
    Creating folder output/src/main/groovy/org/example/dsl/bank
    Generating class PersonSpec for spec person
    Generating class StatisticsSpec for spec statistics
    Generating class TransactionSpec for spec transaction
    Generating class MasterScriptSpec for spec masterScript
    Generating class DelegateTrait for closure delegation
    Generating sample dsl file example.dsl
    To parse DSL: groovy -cp output/src/main/groovy -b org.example.dsl.bank.MasterScriptSpec output/example.dsl

Generated output is in `output` directory (see output above)

    $ cat output/example.dsl

    account "krbrtgnggmh", {
        balance 480, {
            age 629
            name "oklfpctwhx"
            surname "xvnioishjlbryhxlqc"
        }
        accountInfo 754, {
            age 17
            name "ewxtysphpdgmqody"
            surname "kjtnasw"
        }, 70
    }
    manager {
        age 41
        name "exxwbtvxunobcskoky"
        surname "lheucrxuozzcdya"
    }

Groovy DSL run :

    $ groovy -cp output/src/main/groovy -b org.example.dsl.bank.MasterScriptSpec output/example.dsl

    account: txt1=krbrtgnggmh
    balance: num1=480
    age: num1=629
    name: txt1=oklfpctwhx
    surname: txt1=xvnioishjlbryhxlqc
    accountInfo: num1=754
    age: num1=17
    name: txt1=ewxtysphpdgmqody
    surname: txt1=kjtnasw
    accountInfo: num3=70
    age: num1=41
    name: txt1=exxwbtvxunobcskoky
    surname: txt1=lheucrxuozzcdya

# definition syntax

See `samples-*` for appropriate (or forbidden syntax)

`@org.example.pwet` defines the package the classes belong to, to `org.example.pwet`. MUST be first definition in file.

`%typename { ... }` defines a custom type, ie a class `Typename` and its content `...`. This is used to include closure in later weyword definitions

`keyword type, type, type...` defines a keyword at the appropriate level (inside a custom closure or at top-level) and `...` are its parameter types

Types can be :

- `num` (mapped to an `int in groovy code)
- `txt` (mapped to a `String` in groovy code)
- `%typename` (mapped to a closure, delegated to an object of type `Typename`)

Refer to samples for pragmatic examples.

# non-working syntax

## examples

The samples in `samples-broken` are provided to show what does not work and why (explained as per error messages)

## case of `closure-with-*.def`

These files produce "_cannot have multiple custom types on same definition without re-introducing parenthesis in target dsl text_" error message.

In fact, these definitions could work. But Groovy parenthesis simplification make it so that:

For example :

    // works (closure second)
    a 1, {
        b 1
    }

    // works (closure first with parenthesis)
    a({
        b 1
    }, 1)

    // Groovy exception (closure first without parenthesis)
    a {
        b 1
    }, 1


While this would not (exception generated by Groovy on runtime)

    // works (double closure with parenthesis)
    a({
        b 1
    }, {
        b 1
    })

    // exception (double closure without parenthesis)
    a {
        b 1
    }, {
        b 1
    }

TL;DR : it seems you cannot have a closure as *first* argument *and* have somethin behind it *without* adding parenthesis back into to the DSL language. That's why i blocked it, as we want the simplest DSL possible.
